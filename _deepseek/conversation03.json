[
  {
    "question": "Conversation_02.mdMD 304.84KBHow to get the channel IDs that my account is subscribed to?",
    "answer": "Ah! I completely misunderstood. The capper name and watermark are text below the image in the Telegram post, not part of the image itself! This is much easier to handle. We need to extract the text from the message, not from the OCR.Fixed Message ProcessingpythonCopyDownload# Update the process_message method to handle text below images:\n\nasync def process_message(self, message, channel_name):\n    \"\"\"Enhanced message processing - FIXED VERSION for text below images\"\"\"\n    start_time = datetime.now()\n    try:\n        # Get BOTH the image AND the text below it\n        message_text = message.text or \"\"\n        has_media = message.media and hasattr(message.media, 'photo')\n        \n        if not has_media:\n            return  # Skip messages without images\n        \n        # Extract capper from the text below the image\n        capper = self.extract_capper_from_message_text(message_text)\n        \n        if not capper or capper == 'Unknown':\n            logger.info(f\"ğŸ” No capper found in message text: {message_text[:100]}...\")\n            # We can still process the image, but with unknown capper\n            capper = 'Unknown'\n        \n        # Download and process the image\n        temp_file = f\"data/temp/temp_{message.id}_{int(datetime.now().timestamp())}.jpg\"\n        file_path = await message.download_media(file=temp_file)\n        \n        if file_path:\n            async with aiofiles.open(file_path, 'rb') as f:\n                image_data = await f.read()\n            \n            # Process image with OCR\n            text, ocr_confidence = self.enhanced_ocr_processing(image_data)\n            \n            if text.strip():\n                picks = self.parse_sports_picks(text, capper)  # Pass the capper we found\n                \n                if picks:\n                    self.save_picks_to_db(picks, channel_name, message.date, image_data, ocr_confidence, message.id)\n                    self.new_picks_count += len(picks)\n                    self.total_picks_processed += len(picks)\n                    logger.info(f\"âœ… Processed {len(picks)} picks from {capper} (New: {self.new_picks_count}, Total: {self.total_picks_processed})\")\n                else:\n                    logger.info(f\"â„¹ï¸  No picks found in image from {capper}\")\n            \n            # Clean up\n            if os.path.exists(file_path):\n                os.remove(file_path)\n            \n            # Update performance stats\n            processing_time = (datetime.now() - start_time).total_seconds()\n            self.performance_stats['images_processed'] += 1\n            self.performance_stats['avg_processing_time'] = (\n                self.performance_stats['avg_processing_time'] * 0.9 + processing_time * 0.1\n            )\n                \n    except Exception as e:\n        logger.error(f\"âŒ Error processing message: {e}\")\n        self.performance_stats['errors_count'] += 1\n\ndef extract_capper_from_message_text(self, message_text):\n    \"\"\"Extract capper name from the text below the image - SIMPLE VERSION\"\"\"\n    if not message_text or not message_text.strip():\n        return 'Unknown'\n    \n    # The format is typically:\n    # NickyCashin\n    # â–â–â–â–â–\n    # DMâ¡ï¸@cappersfreeâœ…\n    \n    # Split by lines and look for the capper name\n    lines = message_text.strip().split('\\n')\n    \n    # The capper name is usually the first line\n    if lines:\n        first_line = lines[0].strip()\n        # Check if it looks like a capper name (CamelCase, no special chars)\n        if (re.match(r'^[A-Z][a-z]+[A-Z][a-z]+$', first_line) or\n            re.match(r'^[A-Z][a-z]+$', first_line)):\n            logger.info(f\"ğŸ” Found capper in message text: {first_line}\")\n            return first_line\n    \n    # Alternative: look for any CamelCase word in the text\n    camelcase_match = re.search(r'\\b([A-Z][a-z]+[A-Z][a-z]+)\\b', message_text)\n    if camelcase_match:\n        capper = camelcase_match.group(1)\n        logger.info(f\"ğŸ” Found capper via CamelCase: {capper}\")\n        return capper\n    \n    return 'Unknown'\n\n# Update the parse_sports_picks method to accept capper as parameter:\ndef parse_sports_picks(self, text, capper='Unknown'):\n    \"\"\"Parse sports picks from OCR text with provided capper\"\"\"\n    picks = []\n    \n    # Enhanced team recognition\n    nba_teams = {\n        'LAL', 'LAC', 'GSW', 'BOS', 'PHI', 'MIL', 'DEN', 'PHX', 'DAL', 'MIA',\n        'ATL', 'CHI', 'CLE', 'DET', 'HOU', 'IND', 'MEM', 'MIN', 'NOP', 'NYK',\n        'BKN', 'ORL', 'POR', 'SAC', 'SAS', 'OKC', 'UTA', 'WAS', 'TOR', 'CHA'\n    }\n    \n    nfl_teams = {\n        'SF', 'KC', 'PHI', 'DAL', 'BUF', 'BAL', 'MIA', 'DET', 'LAR', 'GB',\n        'CIN', 'SEA', 'PIT', 'LAC', 'MIN', 'NO', 'ATL', 'TB', 'CHI', 'NYJ',\n        'NYG', 'JAX', 'TEN', 'LV', 'ARI', 'NE', 'WAS', 'CAR', 'DEN', 'CLE', 'HOU', 'IND'\n    }\n    \n    # Clean the OCR text\n    cleaned_text = self.clean_ocr_text(text)\n    \n    # Multiple patterns for team detection\n    patterns = [\n        r'([A-Z]{2,4})\\s+(?:vs|@|-)\\s+([A-Z]{2,4})',\n        r'([A-Z]{2,4})\\s+at\\s+([A-Z]{2,4})',\n        r'([A-Z]{2,4})\\s+v\\s+([A-Z]{2,4})',\n        r'([A-Z]{2,4})\\s+VS\\s+([A-Z]{2,4})',\n    ]\n    \n    for pattern in patterns:\n        matches = re.finditer(pattern, cleaned_text, re.IGNORECASE)\n        for match in matches:\n            team1, team2 = match.groups()\n            team1, team2 = team1.upper(), team2.upper()\n            \n            sport = 'UNKNOWN'\n            if team1 in nba_teams or team2 in nba_teams:\n                sport = 'NBA'\n            elif team1 in nfl_teams or team2 in nfl_teams:\n                sport = 'NFL'\n            \n            if sport != 'UNKNOWN':\n                pick = {\n                    'handicapper': capper,  # Use the capper from message text\n                    'sport': sport,\n                    'teams': f\"{team1} vs {team2}\",\n                    'pick_type': self.extract_pick_type(cleaned_text),\n                    'pick_value': self.extract_pick_value(cleaned_text),\n                    'confidence': self.calculate_confidence(cleaned_text, capper)\n                }\n                picks.append(pick)\n                logger.info(f\"ğŸ¯ {capper}: {sport} - {team1} vs {team2}\")\n    \n    return picks\n\ndef clean_ocr_text(self, text):\n    \"\"\"Clean OCR text without removing capper names\"\"\"\n    # Basic cleaning for OCR artifacts\n    cleaned = re.sub(r'\\s+', ' ', text)  # Normalize spaces\n    cleaned = re.sub(r'[^\\w\\s@.\\-+()]', '', cleaned)  # Remove special chars but keep essentials\n    return cleaned.strip()Also Update the FilteringSince the watermark is in the message text (not the image), we need to update the filtering:pythonCopyDownloaddef should_filter_message(self, message_text, ocr_text=\"\"):\n    \"\"\"Check if message should be filtered - UPDATED for text below images\"\"\"\n    if not message_text or not message_text.strip():\n        return False, \"Empty message text\"\n    \n    text_lower = message_text.lower().strip()\n    \n    # Check if this is just a watermark post with no other content\n    watermark_patterns = [\n        r'^[A-Za-z]+\\s*[\\nâ–â€•â”€\\-]+\\s*DMâ¡ï¸@cappersfreeâœ…$',  # Just capper + watermark\n        r'^DMâ¡ï¸@cappersfreeâœ…$',  # Only watermark\n    ]\n    \n    for pattern in watermark_patterns:\n        if re.match(pattern, message_text, re.IGNORECASE | re.MULTILINE):\n            return True, \"Only watermark with no additional content\"\n    \n    # Keep other spam filtering but be more lenient\n    spam_patterns = [\n        r'(?i)buy now',\n        r'(?i)limited time offer',\n        r'(?i)click here to buy',\n        r'(?i)sign up.*paid',\n    ]\n    \n    for pattern in spam_patterns:\n        if re.search(pattern, text_lower):\n            return True, f\"Spam pattern: {pattern}\"\n    \n    return False, \"OK - Contains legitimate content\"Update the Message HandlerpythonCopyDownload# In the monitor method, update the handler:\n\n@self.client.on(events.NewMessage(chats=channel))\nasync def handler(event):\n    if not self.is_running:\n        return\n        \n    if event.message.id &lt;= self.last_processed_message_id:\n        return  # Skip already processed messages\n        \n    if event.message.media and hasattr(event.message.media, 'photo'):\n        message_time = event.message.date.replace(tzinfo=None)\n        seven_days_ago = datetime.now() - timedelta(days=7)\n        \n        if message_time &gt;= seven_days_ago:\n            # Check filtering on the message text (text below image)\n            message_text = event.message.text or \"\"\n            should_filter, reason = self.should_filter_message(message_text)\n            \n            if should_filter:\n                logger.info(f\"ğŸ›¡ï¸  Filtered message {event.message.id}: {reason}\")\n                self.performance_stats['messages_filtered'] += 1\n                self.save_filtered_message(event.message.id, reason)\n                return\n            \n            logger.info(f\"ğŸ†• New post detected at {message_time.strftime('%H:%M:%S')} (ID: {event.message.id})\")\n            await self.process_message(event.message, channel.title)\n            self.last_processed_message_id = event.message.id\n            self.save_state()Now the monitor will:âœ… Extract the capper name from the text below the image (like \"NickyCashin\")âœ… Process the image with OCR to get the sports picksâœ… Combine both to create complete pick recordsâœ… Only filter posts that are purely watermarks with no other contentThis should correctly identify \"NickyCashin\" as the capper and process the picks from the image! ğŸ¯This response is AI-generated, for reference only."
  },
  {
    "question": "This is the channel I want to scrap:\n\nğŸ” Searching for: 'CAPPERS FREEğŸ’'\n==================================================\nâœ… FOUND BY NAME:\n   ğŸ“› CAPPERS FREEğŸ’\n   ğŸ†” 2268137351\n   ğŸ‘¥ 4942 participants\n-------------------------",
    "answer": ""
  },
  {
    "question": "Signed in successfully as Otomo; remember to not break the ToS or you will risk an account ban!\nâŒ Error: Cannot find any entity corresponding to \"2268137351\"",
    "answer": ""
  },
  {
    "question": "ğŸ” Finding CAPPERS FREE channel with correct format...\nâœ… Found: CAPPERS FREEğŸ’\nğŸ†” Raw ID: 2268137351\nğŸ“ Type: Channel\nğŸ”’ Private channel ID: -1002268137351\nğŸ’¡ Use in .env: SOURCE_CHANNEL=-1002268137351\nâŒ Cannot export invite link (need admin rights)\nâœ… Found: CAPPERS FREEï¸âœ¨\nğŸ†” Raw ID: 3146259123\nğŸ“ Type: Channel\nğŸ”’ Private channel ID: -1003146259123\nğŸ’¡ Use in .env: SOURCE_CHANNEL=-1003146259123\nâŒ Cannot export invite link (need admin rights)",
    "answer": ""
  },
  {
    "question": "(.venv) mark@mark-GP66-Leopard-11UH:~/picksai-consensus-engine$ /home/mark/picksai-consensus-engine/.venv/bin/python /home/mark/picksai-consensus-engine/test_cappers_channel.py\nâŒ Error: Cannot find any entity corresponding to \"-1002268137351\"",
    "answer": ""
  },
  {
    "question": "âœ… SUCCESS! Can access channel using entity object\n\nğŸ’¡ For your monitor, use this exact entity:\n   Channel: CAPPERS FREEğŸ’\n   Entity ID: 2268137351\n   Entity: Channel(id=2268137351, title='CAPPERS FREEğŸ’', photo=ChatPhoto(photo_id=5224538956799010729, dc_id=2, has_video=False, stripped_thumb=b'\\x01\\x08\\x08\\x08l\\xe4u\\xc5\\x14Q\\\\N^G+\\x97\\x91'), date=datetime.datetime(2024, 11, 10, 2, 55, 27, tzinfo=datetime.timezone.utc), creator=False, left=False, broadcast=True, verified=False, megagroup=False, restricted=False, signatures=False, min=False, scam=False, has_link=False, has_geo=False, slowmode_enabled=False, call_active=False, call_not_empty=False, fake=False, gigagroup=False, noforwards=True, join_to_send=False, join_request=False, forum=False, stories_hidden=False, stories_hidden_min=False, stories_unavailable=True, signature_profiles=False, autotranslation=False, broadcast_messages_allowed=False, monoforum=False, forum_tabs=False, access_hash=-4963829493951674818, username=None, restriction_reason=[], admin_rights=None, banned_rights=None, default_banned_rights=None, participants_count=4942, usernames=[], stories_max_id=None, color=None, profile_color=None, emoji_status=None, level=None, subscription_until_date=None, bot_verification_icon=None, send_paid_messages_stars=None, linked_monoforum_id=None)",
    "answer": ""
  },
  {
    "question": "(.venv) mark@mark-GP66-Leopard-11UH:~/picksai-consensus-engine$ python smart_monitor.py\nğŸ§  Starting Smart Monitor v2.2 with Direct Channel Access...\nğŸ¯ Target: CAPPERS FREEğŸ’\nTraceback (most recent call last):\n  File \"/home/mark/picksai-consensus-engine/smart_monitor.py\", line 243, in &lt;module&gt;\n    asyncio.run(main())\n  File \"/usr/lib/python3.12/asyncio/runners.py\", line 194, in run\n    return runner.run(main)\n           ^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/asyncio/runners.py\", line 118, in run\n    return self._loop.run_until_complete(task)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/asyncio/base_events.py\", line 687, in run_until_complete\n    return future.result()\n           ^^^^^^^^^^^^^^^\n  File \"/home/mark/picksai-consensus-engine/smart_monitor.py\", line 220, in main\n    monitor = SmartMonitor()\n              ^^^^^^^^^^^^^^\n  File \"/home/mark/picksai-consensus-engine/smart_monitor.py\", line 108, in __init__\n    self.init_database()\n    ^^^^^^^^^^^^^^^^^^\nAttributeError: 'SmartMonitor' object has no attribute 'init_database'",
    "answer": ""
  },
  {
    "question": "(.venv) mark@mark-GP66-Leopard-11UH:~/picksai-consensus-engine$ python smart_monitor.py\nğŸ§  Starting Smart Monitor v2.2 with Direct Channel Access...\nğŸ¯ Target: CAPPERS FREEğŸ’\n2025-11-09 08:43:09,823 - INFO - âœ… Database initialized with optimized schema\n2025-11-09 08:43:09,826 - INFO - Connecting to 149.154.175.60:443/TcpFull...\n2025-11-09 08:43:10,577 - INFO - Connection to 149.154.175.60:443/TcpFull complete!\n2025-11-09 08:43:11,069 - INFO - Connecting to 149.154.175.60:443/TcpFull...\n2025-11-09 08:43:11,142 - INFO - Connection to 149.154.175.60:443/TcpFull complete!\n2025-11-09 08:43:11,716 - INFO - ğŸ§  Smart Monitor Started\n2025-11-09 08:43:11,716 - INFO - ğŸ¤– Scraping as: Otomo\n2025-11-09 08:43:11,716 - INFO - ğŸ” Finding CAPPERS FREE channel in dialogs...\n2025-11-09 08:43:12,085 - INFO - âœ… Found channel: CAPPERS FREEğŸ’\n2025-11-09 08:43:12,086 - INFO -    ğŸ†” Entity ID: 2268137351\n2025-11-09 08:43:12,086 - INFO -    ğŸ‘¥ Participants: 4942\n2025-11-09 08:43:12,164 - INFO - ğŸ“¢ Reporting via: The Line Weaver\n2025-11-09 08:43:12,164 - INFO - ğŸ¯ Source: CAPPERS FREEğŸ’\n2025-11-09 08:43:12,164 - INFO - ğŸ“Š Reports: @TheLineWeaverReports\n2025-11-09 08:43:12,164 - INFO - â° Interval: 20 minutes\n2025-11-09 08:43:12,164 - INFO - ğŸ›¡ï¸  Filtering: 19 patterns\n2025-11-09 08:43:12,164 - INFO - ==================================================\n2025-11-09 08:43:12,164 - INFO - ğŸ¯ Monitoring: CAPPERS FREEğŸ’\n2025-11-09 08:43:12,164 - INFO - ğŸ”„ Monitor running... (Ctrl+C to stop)",
    "answer": ""
  },
  {
    "question": "post are being filtered out when they should not be!\n\n2025-11-09 08:44:02,540 - INFO - ğŸ›¡ï¸  Filtered message 31851: Matched pattern: (?i)@cappersfree\n2025-11-09 08:45:57,393 - INFO - ğŸ†• New post detected at 16:45:55 (ID: 31852)\n2025-11-09 08:45:57,393 - INFO - ğŸ›¡ï¸  Filtered message 31852: Matched pattern: (?i)@cappersfree\n2025-11-09 08:45:57,411 - INFO - ğŸ†• New post detected at 16:45:55 (ID: 31853)\n2025-11-09 08:45:57,411 - INFO - ğŸ›¡ï¸  Filtered message 31853: Matched pattern: (?i)@cappersfree\n2025-11-09 08:45:57,419 - INFO - ğŸ†• New post detected at 16:45:55 (ID: 31854)\n2025-11-09 08:45:57,420 - INFO - ğŸ›¡ï¸  Filtered message 31854: Matched pattern: (?i)@cappersfree",
    "answer": ""
  },
  {
    "question": "Ok, the capper is not being correctly found. In the telegram post, at the bottom of the frame, is the capper name. it is not in the image! It looks like this:\n\nNickyCashin\nâ–â–â–â–â–\nDMâ¡ï¸@cappersfreeâœ…\n\nNickyCashin  is the capper, everything else can be ignored",
    "answer": ""
  },
  {
    "question": "This is all actually text below the image:\nNickyCashin\nâ–â–â–â–â–\nDMâ¡ï¸@cappersfreeâœ…",
    "answer": ""
  }
]